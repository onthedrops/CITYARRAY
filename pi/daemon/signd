#!/usr/bin/perl

use FindBin;
use IO::Socket::INET;
use Data::Dumper;
use RPi::Pin;
use RPi::Const qw(:all);
use LWP::UserAgent;

$VER = "0.15";


push(@INC, $FindBin::Bin . "/../lib");

require S2Config;
require S2dbobj;

S2Config::setup('/home/sign-firmware/pi/conf/signd.xml');

$home = S2Config::getHomedir();
$logFile = S2Config::getConfigValue('logfile') || '/var/log/signd.log';

$pidFile = S2Config::getConfigValue('pidfile') || $home . '/run/signd.pid';

if(-f $pidFile) {
	open(PID, "<$pidFile");
	$pid = <PID>;
	close(PID);
	chop($pid);
	if(-d "/proc/$pid") {
		$target = readlink "/proc/$pid";
		if($target =~ /.*signd/) {
			die "Already running ($pid / $target)";
		} else {
			unlink($pidFile);
		}
	}
}

if($main::debug) {
	print S2Config::dumpConfig();
}

if(!S2Config::getConfigValue('nofork')) {
	if($pid = fork()) {
		slog("Child $pid is forking");
		exit(0);
	} else {
		close(STDIN);
		close(STDOUT);
		close(STDERR);
	}	
} else {
	slog("Not forking");
}

open(PID,">$pidFile");
print PID "$$\n";
close(PID);

$dbh = S2dbobj::getHandle();

$SIG{'TERM'} = sigterm;
$SIG{'INT'} = sigterm;

$main::dry_pin = RPi::Pin->new(24);
$main::dry_pin->mode(INPUT);
$main::dry_pin_>write(LOW);

$main::dry_state = 0;

$main::alive = 1;
$lwp = new LWP::UserAgent;

$signIpCache = {};

$tickCounter = 0;

$dbh->do("UPDATE shutdown SET shutdown_requested = 0");
unlink("/home/sign-firmware/pi/www/remote_support.txt");
open(SD,">/home/sign-firmware/pi/www/signd.txt");
print SD "Signd $VER (running as pid $$)\n";
close(SD);
system("(cd /home/sign-firmware ; git rev-parse HEAD >> /home/sign-firmware/pi/www/git.txt)");


$sendQueue = {};

# check to see if sqlUpdates table exists
# if not, add it
($exists) = $dbh->selectrow_array("SHOW TABLES LIKE 'sqlUpdates'");
if(!$exists) {
	$sql=<<EOF;
	CREATE TABLE sqlUpdates (
		sqlUpdateId int not null auto_increment primary key,
		filename varchar(255),
		loadTime timestamp
	);
EOF

	if(!$dbh->do($sql)) {
		print $DBI::errstr . "\n" . $sql . "\n" if($debug);
	} else {
		$exists = 1;	
	}
}

open(UPDATE,">>/var/log/update.log");

if($exists) {

	# iterate the directory vs the table, run all updates
	my $updatepath = '/home/sign-firmware/pi/sql/updates';


	opendir(DH,$updatepath);
	while($file = readdir(DH)) {
		$fullpath = $updatepath . '/' . $file;
		
		if(-f $fullpath && $file =~ /.*\.sql$/) {
			print "Reading $fullpath" if($debug);
	#		print UPDATE "Reading $fullpath\n";

			$fileq = $dbh->quote($file);
			($already_installed) = $dbh->selectrow_array("SELECT filename FROM sqlUpdates WHERE filename = $fileq");
			if(!$already_installed) {
				open(F,"<$fullpath");
				$buf = undef;
				while($in = <F>) {
					$buf .= $in;
					if($in =~ /.*;.*/) {
						if(!$dbh->do($buf)) {
							print "$file error loading: " . $DBI::errstr . "\n" . $sql . "\n" if($debug);
							print UPDATE "$file error loading: " . $DBI::errstr . "\n" . $sql . "\n";
						} else {
							print UPDATE "$file error loaded\n" . $sql . "\n";
							$sql = "INSERT INTO sqlUpdates SET filename=$fileq, loadTime=NOW()";
							$dbh->do($sql);
						}

						$buf = undef;
					}
				}
				close(F);
			}
		}
	}
	closedir(DH);

} else {
	print UPDATE "No sql update table detected so updates not run\n";
}

close(UPDATE);

while($main::alive) {
	my $state = $main::dry_pin->read;
	if($state && !$main::dry_state) {
		slog("High detected");
		$main::dry_state = 1;
		# use LWP to switch to dry contact preset
		$response = $lwp->get("http://localhost/drycontact.php?contact=1");
		slog("R: " . $response->{'_content'});
	} elsif(!$state && $main::dry_state) {
		slog("Low detected");
		$main::dry_state = 0;
		# use LWP to switch to previous message
		$response = $lwp->get("http://localhost/drycontact.php?contact=0");
		slog("R: " . $response->{'_content'});
	}


	if(!($tickCounter++ % 10)) {
		$cmd = S2Config::getConfigValue('gitcmd');

		($shutdown) = $dbh->selectrow_array("SELECT shutdown_requested FROM shutdown");

		if($shutdown == 5) {
				slog("Remote connection requested");
				$dbh->do("UPDATE shutdown SET shutdown_requested = 0");
				if($pid = fork()) {
					# parent
				} else {
					system("/home/sign-firmware/pi/daemon/remote-control");
					exit(0);
				}
		}

		if($shutdown == 1) {
			if(S2Config::getConfigValue('noshutdown')) {
				slog("Shutdown commanded but disabled");
				$dbh->do("UPDATE shutdown SET shutdown_requested = 0");
			} else {
				slog("Commanding shutdown");
				$dbh->do("UPDATE shutdown SET shutdown_requested = 2");
				system("/sbin/shutdown -h now");
			}
		}

		if($shutdown == 3) {
			if(S2Config::getConfigValue('noshutdown')) {
				slog("Shutdown (reboot) commanded but disabled");
				$dbh->do("UPDATE shutdown SET shutdown_requested = 0");
			} else {
				slog("Commanding shutdown (reboot)");
				$dbh->do("UPDATE shutdown SET shutdown_requested = 2");
				system("/sbin/shutdown -r now");
			}
		}

		$sth = $dbh->prepare("SELECT updateId FROM updates WHERE updateVersion IS NULL");
		$sth->execute();
		while(($updateId) = $sth->fetchrow_array()) {
			$buf = undef;
			open(GIT,"$cmd|");
			slog("Running $cmd");
			while($in = <GIT>) {
				slog("in: $in");
				$buf .= $in;
			}
			close(GIT);
			$version = `(cd /home/sign-firmware ; git rev-parse HEAD)`;
			slog("Version: $version");
			chop($version);


			$dbh->do("UPDATE updates SET updatetext=" . $dbh->quote($buf) . ", updateVersion=" . $dbh->quote($version) . " WHERE updateId=$updateId");
		}
	}

	$sth = $dbh->prepare("SELECT signNotifyId, signId FROM signNotifies WHERE notified = 0");
	$sth->execute();

	while($x = $sth->fetchrow_hashref()) {
		push(@workArray, $x);
	}

	while($notify = shift(@workArray)) {
		$signId = $notify->{'signId'};
		$signNotifyId = $notify->{'signNotifyId'};

		if(defined $signIpCache->{$signId} && $signIpCache->{$signId}) {
			$sendIp = $signIpCache->{$signId};
		} else {
			($signIp) = $dbh->selectrow_array("SELECT signIp FROM signs WHERE signId = $signId");
			if($signIp) {
				$signIpCache->{$signId} = $signIp;
				$sendIp = $signIp;
			} else {
				$sendIp = undef;
			}
		}

		if($sendIp) {
			$sendQueue->{$sendIp} = 3;
			$notified = 1;

		} else {
			$notified = -1;
		}
		
		slog("SI: $signId SNI: $signNotifyId sendIp $sendIp notified: $notified");
		$dbh->do("UPDATE signNotifies SET notified = $notified, notifyTime=NOW() WHERE signNotifyId = $signNotifyId");	
	}
		
	foreach $sendIp (keys %{$sendQueue}) {
		if($sendQueue->{$sendIp} == 0) {
			delete $sendQueue->{$sendIp};
		} else {
			$sendQueue->{$sendIp}--;
		}
  $notified = 1;
                $sock = new IO::Socket::INET(PeerAddr => $sendIp,
                	PeerPort => 1234,
                        Proto => 'udp', Timeout => 1);

		if($sock) {
               		print $sock "\n";
                }

		slog("SITX $sendIp ");
	}

	select(undef,undef,undef,0.25);
}

slog("Exiting");

unlink($pidFile);


sub sigterm {
	my $sig = shift;
	$main::alive = 0;
	slog("Got sig $sig shutting down");
}

sub slog {
	my $logFile = $main::logFile;
	my $msg = shift;

	open(LOG,">>$logFile");
	print LOG getTimestamp() . ": " . $msg . "\n";
	print getTimestamp() . ": " .  $msg . "\n" if($main::debug);
	close(LOG);
}

sub getTimestamp {
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time());
        return sprintf("%02d/%02d/%04d-%02d:%02d:%02d",$mon+1,$mday,$year+1900,$hour,$min,$sec);
}

